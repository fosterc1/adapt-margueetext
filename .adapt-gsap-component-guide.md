# Creating GSAP-based Adapt Framework Components

## Critical Lessons Learned from adapt-scrollMarquee Development

This guide documents the complete journey and solutions for integrating GSAP (GreenSock Animation Platform) into Adapt Framework v5+ components, based on real-world development experience.

---

## Table of Contents

1. [The Core Challenge: AMD vs Global Modules](#the-core-challenge)
2. [Template System Issues](#template-system-issues)
3. [GSAP Loading Solution](#gsap-loading-solution)
4. [Component Structure](#component-structure)
5. [Complete Code Examples](#complete-code-examples)
6. [Testing & Debugging](#testing-debugging)
7. [Common Pitfalls](#common-pitfalls)

---

## The Core Challenge: AMD vs Global Modules

### The Problem

**Adapt Framework v5.53.3 uses RequireJS/AMD for module loading.** When you try to load GSAP via normal `<script>` tags or CDN:

```javascript
// This FAILS in Adapt
const script = document.createElement('script');
script.src = 'https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.5/gsap.min.js';
document.head.appendChild(script);

// After load: window.gsap is UNDEFINED!
```

**Why?** GSAP's UMD (Universal Module Definition) wrapper detects AMD/RequireJS and exports as a module instead of creating global `window.gsap`.

### The Solution

**Temporarily disable AMD detection during GSAP load:**

```javascript
// Save existing AMD/CommonJS globals
const savedDefine = window.define;
const savedExports = window.exports;
const savedModule = window.module;

try {
  // Disable module systems
  window.define = undefined;
  window.exports = undefined;
  window.module = undefined;
  
  // Fetch and eval GSAP code
  const response = await fetch('https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.5/gsap.min.js');
  const code = await response.text();
  eval(code);  // GSAP now creates window.gsap
  
} finally {
  // Restore AMD/CommonJS (critical for Adapt to keep working!)
  if (savedDefine) window.define = savedDefine;
  if (savedExports) window.exports = savedExports;
  if (savedModule) window.module = savedModule;
}
```

**Key Points:**
- Must use `fetch()` + `eval()` instead of `<script>` tags
- Must restore AMD after load
- Must wait for GSAP to attach to window before loading ScrollTrigger

---

## Template System Issues

### JSX vs Handlebars Confusion

**Attempted Approach:** Use JSX templates (seems modern for v5+)

```javascript
// templates/scrollMarquee.jsx
import React from 'react';
export default function ScrollMarquee(props) {
  return <div>...</div>;
}
```

**Result:** Multiple errors:
- `template is not a function`
- `template.includes is not a function`
- Template not found during build

**Root Cause:** Adapt v5.53.3 **still uses Handlebars templates**, not JSX. JSX might be used in newer versions or specific builds, but default installations use Handlebars.

### Solution: Manual Render

Since neither JSX nor Handlebars worked reliably, we used **manual HTML generation**:

```javascript
render() {
  if (this.preRender) {
    this.preRender();
  }
  
  const data = this.model.toJSON();
  
  const html = `
    <div class="component__inner scroll-marquee__inner">
      <div class="component__header">
        ${data.displayTitle ? `<div class="component__title">${data.displayTitle}</div>` : ''}
        ${data.instruction ? `<div class="component__instruction">${data.instruction}</div>` : ''}
      </div>
      <div class="component__widget scroll-marquee__widget">
        <div class="scroll-marquee__inner">
          ${data.body ? `<div class="scroll-marquee__text">${data.body}</div>` : ''}
        </div>
      </div>
    </div>
  `;
  
  this.$el.html(html);
  this.$el.addClass(this.className());
  
  // Call postRender in nextTick
  setTimeout(() => {
    if (this.postRender) {
      this.postRender();
    }
  }, 0);
  
  return this;
}
```

**Critical:** 
- Must call `preRender()` before rendering
- Must call `postRender()` after rendering (in setTimeout to avoid blocking)
- Must return `this` from render method
- `postRender()` must call `this.setReadyStatus()` to tell Adapt component is ready

---

## GSAP Loading Solution

### Complete GSAP Loader Implementation

**File: `js/gsapLoader.js`**

```javascript
class GsapLoader {
  constructor() {
    this.isLoaded = false;
    this.loadPromise = null;
  }

  async load() {
    // Priority 1: Check if GSAP already exists (theme/framework)
    if (window.gsap && window.ScrollTrigger) {
      console.log('ScrollMarquee: Using GSAP from theme/framework');
      this.isLoaded = true;
      return Promise.resolve();
    }

    // If already loading, return existing promise
    if (this.loadPromise) return this.loadPromise;

    this.loadPromise = new Promise((resolve, reject) => {
      
      const fetchAndEval = (url, globalName) => {
        return fetch(url)
          .then(response => response.text())
          .then(code => {
            console.log(`ScrollMarquee: Fetched ${globalName}, evaluating...`);
            
            // Save and disable AMD/CommonJS temporarily
            const savedDefine = window.define;
            const savedExports = window.exports;
            const savedModule = window.module;
            
            try {
              window.define = undefined;
              window.exports = undefined;
              window.module = undefined;
              
              // Eval the code - GSAP should now attach to window
              eval(code);
              
              console.log(`ScrollMarquee: Evaluated ${globalName}`);
              console.log(`ScrollMarquee: window.gsap exists:`, !!window.gsap);
              console.log(`ScrollMarquee: window.ScrollTrigger exists:`, !!window.ScrollTrigger);
            } finally {
              // Restore AMD/CommonJS
              if (savedDefine) window.define = savedDefine;
              if (savedExports) window.exports = savedExports;
              if (savedModule) window.module = savedModule;
            }
          });
      };

      const waitForGlobal = (globalName, maxAttempts = 30) => {
        return new Promise((resolve, reject) => {
          setTimeout(() => {
            if (window[globalName]) {
              console.log(`ScrollMarquee: ${globalName} found on window`);
              resolve();
              return;
            }
            
            console.log(`ScrollMarquee: Waiting for ${globalName}...`);
            let attempts = 0;
            const checkInterval = setInterval(() => {
              attempts++;
              if (window[globalName]) {
                clearInterval(checkInterval);
                console.log(`ScrollMarquee: ${globalName} found after ${attempts} attempts`);
                resolve();
              } else if (attempts >= maxAttempts) {
                clearInterval(checkInterval);
                reject(new Error(`${globalName} not available after loading`));
              }
            }, 100);
          }, 200); // Initial delay
        });
      };
      
      console.log('ScrollMarquee: Loading GSAP via fetch+eval to bypass AMD...');
      
      fetchAndEval('https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.5/gsap.min.js', 'GSAP')
        .then(() => waitForGlobal('gsap'))
        .then(() => fetchAndEval('https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.5/ScrollTrigger.min.js', 'ScrollTrigger'))
        .then(() => waitForGlobal('ScrollTrigger'))
        .then(() => {
          this.isLoaded = true;
          console.log('ScrollMarquee: GSAP and ScrollTrigger ready');
          resolve();
        })
        .catch((error) => {
          console.error('ScrollMarquee: Failed to load GSAP libraries:', error);
          reject(error);
        });
    });

    return this.loadPromise;
  }
}

export default new GsapLoader();
```

**Key Features:**
- ✅ Checks if GSAP already loaded (from theme)
- ✅ Singleton pattern (only loads once)
- ✅ Disables AMD during load
- ✅ Restores AMD after load
- ✅ Sequential loading (GSAP → ScrollTrigger)
- ✅ Polls for global availability
- ✅ Extensive logging for debugging

---

## Component Structure

### Correct File Layout

```
adapt-componentName/
├── js/
│   ├── adapt-componentName.js    # Main entry (registers component)
│   ├── componentNameView.js      # View logic
│   ├── gsapLoader.js             # GSAP loading utility
│   └── [componentName.jsx]       # JSX template (optional, may not work)
├── templates/
│   └── componentName.hbs         # Handlebars (may not be used)
├── libraries/                     # Bundled GSAP (optional)
│   ├── gsap.min.js
│   ├── ScrollTrigger.min.js
│   └── README.md
├── less/
│   └── componentName.less
├── schema/
│   └── component.schema.json
├── bower.json
├── package.json
├── properties.schema
├── example.json
├── README.md
└── LICENSE
```

**Critical:** All files at repository root, not in subdirectory.

### Main Entry File

**File: `js/adapt-scrollMarquee.js`**

```javascript
import components from 'core/js/components';
import ScrollMarqueeView from './scrollMarqueeView';
import ComponentModel from 'core/js/models/componentModel';

export default components.register('scrollMarquee', {
  model: ComponentModel.extend({}),
  view: ScrollMarqueeView
});
```

### View File Structure

**File: `js/scrollMarqueeView.js`**

```javascript
import ComponentView from 'core/js/views/componentView';
import a11y from 'core/js/a11y';
import gsapLoader from './gsapLoader';

class ScrollMarqueeView extends ComponentView {

  className() {
    return [
      super.className(),
      'scroll-marquee'
    ].join(' ');
  }

  render() {
    // Must call preRender
    if (this.preRender) {
      this.preRender();
    }
    
    // Generate HTML
    const data = this.model.toJSON();
    const html = `...`;
    this.$el.html(html);
    this.$el.addClass(this.className());
    
    // Must call postRender (async to avoid blocking)
    setTimeout(() => {
      if (this.postRender) {
        this.postRender();
      }
    }, 0);
    
    return this;
  }

  preRender() {
    this.listenTo(this.model, 'change:_isComplete', this.onCompleteChange);
  }

  postRender() {
    console.log('Component: postRender called');
    
    // CRITICAL: Set ready immediately, don't wait for GSAP
    this.setReadyStatus();
    
    if (this.model.get('_setCompletionOn') === 'inview') {
      this.setupInviewCompletion('.component__widget', this.onInview.bind(this));
    }

    // Load GSAP asynchronously (non-blocking)
    gsapLoader.load()
      .then(() => {
        console.log('Component: GSAP loaded, setting up animation');
        this.setupAnimation();
      })
      .catch((error) => {
        console.warn('Component: Animation disabled', error);
      });
  }

  setupAnimation() {
    const gsap = window.gsap;
    const ScrollTrigger = window.ScrollTrigger;

    if (!gsap || !ScrollTrigger) {
      console.warn('Component: GSAP not found');
      return;
    }

    gsap.registerPlugin(ScrollTrigger);
    
    // Your GSAP animation code here
  }

  remove() {
    // Cleanup GSAP animations
    if (this.scrollTrigger) {
      this.scrollTrigger.kill();
    }
    super.remove();
  }
}

export default ScrollMarqueeView;
```

**Critical Points:**
- ✅ Override `render()` if not using templates
- ✅ Call `this.setReadyStatus()` IMMEDIATELY in `postRender()`
- ✅ Load GSAP asynchronously (don't block ready status)
- ✅ Gracefully handle GSAP load failure
- ✅ Clean up animations in `remove()`

---

## Complete Code Examples

### Properties Schema

**File: `properties.schema`**

```json
{
  "$ref": "http://localhost/plugins/content/component/model.schema",
  "properties": {
    "_speed": {
      "type": "number",
      "default": 1,
      "title": "Scroll Speed",
      "help": "Controls the speed. 1 = Slow, 2 = Medium, 3 = Fast. Range: 1 to 5",
      "minimum": 1,
      "maximum": 5
    }
  }
}
```

**Key Points:**
- Use `$ref` directly, not wrapped in `pluginLocations`
- Use absolute values in LESS (not theme variables)

### LESS Styling

**File: `less/scrollMarquee.less`**

```less
.scroll-marquee {
  
  &__widget {
    overflow: hidden;
    position: relative;
  }
  
  &__inner {
    display: flex;
    white-space: nowrap;
    will-change: transform;
  }
  
  &__text {
    padding-right: 50px;
  }
}

// Use absolute values, not theme variables
.scroll-marquee__text {
  color: #666;  // Not @item-text-color-disabled
}

@media (max-width: 900px) {  // Not @device-width-medium
  .scroll-marquee {
    // Responsive styles
  }
}
```

**Critical:** Don't use theme LESS variables - they may not be defined during plugin compilation.

### bower.json

```json
{
  "name": "adapt-scrollMarquee",
  "version": "3.4.3",
  "framework": "^5.0.0",
  "homepage": "https://github.com/username/adapt-scrollMarquee",
  "displayName": "Scrolling Marquee Text",
  "component": "scrollMarquee",
  "description": "A scroll-velocity-based marquee component using GSAP",
  "main": "/js/adapt-scrollMarquee.js",
  "keywords": [
    "adapt-plugin",
    "adapt-component"
  ],
  "license": "GPL-3.0",
  "targetAttribute": "_component"
}
```

---

## Testing & Debugging

### Console Output for Successful Load

```
ScrollMarquee: postRender called
ScrollMarquee: Loading GSAP from CDN...
ScrollMarquee: Loading GSAP via fetch+eval to bypass AMD...
ScrollMarquee: Fetched GSAP, evaluating...
ScrollMarquee: Evaluated GSAP
ScrollMarquee: window.gsap exists: true
ScrollMarquee: window.ScrollTrigger exists: false
ScrollMarquee: gsap found on window immediately
ScrollMarquee: Fetched ScrollTrigger, evaluating...
ScrollMarquee: Evaluated ScrollTrigger
ScrollMarquee: window.ScrollTrigger exists: true
ScrollMarquee: ScrollTrigger found on window immediately
ScrollMarquee: GSAP and ScrollTrigger ready
ScrollMarquee: GSAP loaded, setting up marquee
```

### Common Error Patterns

**1. "template is not a function"**
- Solution: Don't rely on template system, use manual render()

**2. "window.gsap is undefined"**
- Solution: AMD is capturing GSAP, use fetch+eval with AMD disable

**3. "Cannot set property window"**
- Solution: Don't pass window as IIFE parameter, use global window

**4. "Component failed to become ready"**
- Solution: Call `setReadyStatus()` immediately, load GSAP async

**5. "gsap not available after loading"**
- Solution: Add polling with delay (200ms initial + 100ms intervals)

### Debugging Checklist

When GSAP doesn't load:

```javascript
// Add to waitForGlobal function
console.log('window.gsap type:', typeof window.gsap);
console.log('window.ScrollTrigger type:', typeof window.ScrollTrigger);
console.log('window.define type:', typeof window.define);
console.log('window.exports type:', typeof window.exports);
```

---

## Common Pitfalls

### 1. ❌ Using `<script>` Tags for GSAP

```javascript
// WRONG - AMD will capture this
const script = document.createElement('script');
script.src = 'cdnjs.../gsap.min.js';
document.head.appendChild(script);
```

**Why it fails:** RequireJS intercepts script loads.

### 2. ❌ Forgetting to Restore AMD

```javascript
// WRONG - Breaks Adapt
window.define = undefined;
eval(gsapCode);
// Missing: window.define = savedDefine;
```

**Why it fails:** Adapt needs AMD to load other modules.

### 3. ❌ Waiting for GSAP Before setReadyStatus()

```javascript
// WRONG - Blocks component ready
postRender() {
  await gsapLoader.load();
  this.setReadyStatus();  // Too late!
}
```

**Why it fails:** Parent views timeout waiting for component.

**Correct:**
```javascript
postRender() {
  this.setReadyStatus();  // Immediate
  gsapLoader.load().then(() => this.setupAnimation());
}
```

### 4. ❌ Using Theme LESS Variables

```less
// WRONG - May not be defined
.scroll-marquee {
  color: @item-text-color-disabled;
}
```

**Why it fails:** Plugin compiles separately from theme.

**Correct:**
```less
.scroll-marquee {
  color: #666;  // Absolute value
}
```

### 5. ❌ Not Cleaning Up GSAP

```javascript
// WRONG - Memory leak
remove() {
  super.remove();
}
```

**Correct:**
```javascript
remove() {
  if (this.scrollTrigger) {
    this.scrollTrigger.kill();
  }
  super.remove();
}
```

---

## Git Workflow

### Version Management

After EVERY code change:

```bash
# 1. Make changes
# 2. Commit
git add -A
git commit -m "fix: Description of change"

# 3. Update version
# Edit bower.json and package.json

# 4. Commit version
git add bower.json package.json
git commit -m "chore: Bump version to X.Y.Z"

# 5. Push and tag
git push origin main
git tag -a vX.Y.Z -m "Version X.Y.Z - Description"
git push origin vX.Y.Z
```

### Version Numbering

- **Patch (X.Y.Z):** Bug fixes, no breaking changes
- **Minor (X.Y.0):** New features, backwards compatible
- **Major (X.0.0):** Breaking changes

---

## Performance Considerations

### 1. GSAP Load Time

- **CDN Load:** ~100-300ms
- **Polling Wait:** 200ms + up to 3000ms
- **Total:** Component ready immediately, animation ~500-3500ms later

### 2. Memory Management

```javascript
remove() {
  // Kill all ScrollTriggers
  if (this.scrollTrigger) {
    this.scrollTrigger.kill();
  }
  
  // Kill all GSAP animations on this element
  if (window.gsap) {
    window.gsap.killTweensOf(this.el);
  }
  
  super.remove();
}
```

### 3. Bundled vs CDN

**Bundled GSAP (115 KB):**
- ✅ Faster (no network)
- ✅ Offline support
- ❌ Larger plugin size
- ❌ Path detection complex in Adapt

**CDN:**
- ✅ Smaller plugin
- ✅ Cached across sites
- ❌ Requires internet
- ❌ ~300ms load time

**Recommendation:** Start with CDN (simpler), add bundling later if needed.

---

## Summary: The Complete Solution

### Essential Code Pattern

```javascript
// 1. GSAP Loader with AMD bypass
const fetchAndEval = (url) => {
  return fetch(url)
    .then(r => r.text())
    .then(code => {
      const savedDefine = window.define;
      try {
        window.define = undefined;
        eval(code);
      } finally {
        if (savedDefine) window.define = savedDefine;
      }
    });
};

// 2. Sequential loading
await fetchAndEval('gsap.min.js');
await fetchAndEval('ScrollTrigger.min.js');

// 3. Manual render with lifecycle
render() {
  this.preRender?.();
  this.$el.html(html);
  setTimeout(() => this.postRender?.(), 0);
  return this;
}

// 4. Immediate ready status
postRender() {
  this.setReadyStatus();  // First!
  gsapLoader.load().then(() => this.setupAnimation());
}
```

### Success Criteria

✅ Component displays immediately
✅ No "failed to become ready" errors
✅ GSAP loads asynchronously  
✅ Animation works when GSAP ready
✅ Graceful degradation if GSAP fails
✅ No AMD/RequireJS conflicts
✅ Proper cleanup in remove()

---

## Conclusion

Creating GSAP components for Adapt Framework requires:

1. **Understanding AMD conflict** and using fetch+eval bypass
2. **Manual rendering** instead of template systems
3. **Immediate ready status** with async GSAP loading
4. **Careful AMD restoration** to not break Adapt
5. **Extensive logging** for debugging
6. **Graceful degradation** when GSAP fails

This pattern is now proven and can be reused for any GSAP-based Adapt component.

---

**Version:** 1.0  
**Last Updated:** 2024-11-08  
**Tested With:** Adapt Framework v5.53.3, Authoring Tool v0.11.5  
**GSAP Version:** 3.12.5

