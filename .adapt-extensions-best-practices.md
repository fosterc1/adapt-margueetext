# Adapt Framework Extension Development - Best Practices Guide

**Version:** 1.0.0  
**Last Updated:** 2025-11-08  
**Framework:** Adapt Framework v5.14.0+  
**Based on:** adapt-backgroundVideo extension

This guide documents best practices for developing **Adapt Extensions** (as opposed to Components). Extensions add functionality across multiple content types (menu, page, article, block).

---

## Table of Contents

1. [Components vs Extensions](#components-vs-extensions)
2. [Extension Architecture](#extension-architecture)
3. [React Integration](#react-integration)
4. [Video Handling](#video-handling)
5. [Device-Responsive Assets](#device-responsive-assets)
6. [Intersection Observer Pattern](#intersection-observer-pattern)
7. [Error Handling & Fallbacks](#error-handling--fallbacks)
8. [Extension-Specific Patterns](#extension-specific-patterns)

---

## Components vs Extensions

### When to Build a Component

**Components** are standalone content elements:
- ✅ Display in article/block areas
- ✅ Have their own data model
- ✅ Appear once per instance
- ✅ Example: scrollMarquee, accordion, hotgraphic

### When to Build an Extension

**Extensions** add functionality to existing elements:
- ✅ Apply to multiple content types (menu/page/article/block)
- ✅ Enhance existing views
- ✅ Background functionality
- ✅ Example: backgroundVideo, pageLevelProgress, resources

---

## Extension Architecture

### Extension Registration

**File:** `js/adapt-[extensionName].js`

```javascript
import Adapt from 'core/js/adapt';
import ExtensionView from './extensionView';

class Extension extends Backbone.Controller {
  initialize() {
    this.listenTo(Adapt, 'app:dataReady', this._onDataReady);
  }

  _onDataReady() {
    this.setupEventListeners();
  }

  setupEventListeners() {
    // Listen to multiple view types
    this.listenTo(Adapt, {
      'menuView:postRender': this.onPostRender,
      'pageView:postRender': this.onPostRender,
      'articleView:postRender': this.onPostRender,
      'blockView:postRender': this.onPostRender
    });
  }

  onPostRender(view) {
    const viewModel = view.model;
    
    // Check if extension is enabled for this view
    if (!this.checkIsEnabled(viewModel)) return;
    
    // Get extension configuration
    const config = viewModel.get('_extensionName');
    
    // Create and inject view
    const extensionView = new ExtensionView({ 
      model: viewModel,
      config: config
    });
    
    // Inject into appropriate element
    const selector = config._selector || view.$el;
    $(selector).prepend(extensionView.el).addClass('has-extension');
  }

  checkIsEnabled(model) {
    const config = model.get('_extensionName');
    if (!config || !config._isEnabled) return false;
    return true;
  }
}

export default new Extension();
```

### Key Differences from Components

| Aspect | Component | Extension |
|--------|-----------|-----------|
| **Registration** | `components.register()` | `new Backbone.Controller()` |
| **Lifecycle** | Own render cycle | Inject into existing views |
| **Data** | Component model | Host model with extension config |
| **Events** | componentView events | Multiple view type events |
| **Location** | Article/block area | Any element via selector |

---

## React Integration

### Using React in Extensions (Adapt v5.14+)

**✅ RECOMMENDED** for modern Adapt versions:

```javascript
import React from 'react';
import ReactDOM from 'react-dom';
import { templates } from 'core/js/reactHelpers';

class ExtensionView extends Backbone.View {
  
  render() {
    const data = this.prepareData();
    
    // Use React for rendering
    ReactDOM.render(
      <templates.extensionTemplate {...data} />,
      this.el
    );
    
    return this;
  }

  prepareData() {
    return {
      config: this.config,
      // ... other props
    };
  }

  remove() {
    // Cleanup React
    ReactDOM.unmountComponentAtNode(this.el);
    super.remove();
  }
}
```

### JSX Templates

Create `templates/extension.jsx`:

```jsx
import React from 'react';

export default function ExtensionTemplate(props) {
  const { config } = props;
  
  return (
    <div className="extension">
      <div className="extension__content">
        {/* Your template */}
      </div>
    </div>
  );
}
```

### When to Use React vs Manual HTML

**Use React when:**
- ✅ Adapt v5.14+ (has React support)
- ✅ Complex dynamic UI
- ✅ Frequent re-renders needed
- ✅ Event handling is complex

**Use Manual HTML when:**
- ✅ Adapt v5.53.3 or older
- ✅ Simple, static templates
- ✅ Performance critical
- ✅ Minimal dependencies

---

## Video Handling

### HTML5 Video Best Practices

```javascript
class VideoView extends Backbone.View {
  
  initialize() {
    this.videoListenersAdded = false;
    this.hasUserPaused = false;
    this.isLoopsComplete = false;
    this.setupVideo();
  }

  setupVideo() {
    // Wait for video element to exist
    this.$video = this.$('video');
    this.video = this.$video[0];
    
    if (!this.video) return;
    
    this.setupVideoListeners();
    this.setupAutoplay();
  }

  setupVideoListeners() {
    if (!this.video || this.videoListenersAdded) return;
    
    // Playback events
    this.video.addEventListener('ended', this.onVideoEnded.bind(this));
    this.video.addEventListener('play', this.updateState.bind(this));
    this.video.addEventListener('pause', this.updateState.bind(this));
    this.video.addEventListener('playing', this.updateState.bind(this));
    
    // Loading events
    this.video.addEventListener('loadstart', this.onLoadStart.bind(this));
    this.video.addEventListener('loadeddata', this.onLoadedData.bind(this));
    this.video.addEventListener('loadedmetadata', this.onLoadedMetadata.bind(this));
    
    // Error handling
    this.video.addEventListener('error', this.onVideoError.bind(this));
    
    this.videoListenersAdded = true;
  }

  setupAutoplay() {
    if (!this.config._autoPlay) return;
    
    // Respect reduced motion
    const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
    if (prefersReducedMotion) {
      this.config._autoPlay = false;
      this.hasUserPaused = true;
      return;
    }
    
    // Try to play with promise handling
    const playPromise = this.video.play();
    
    if (playPromise !== undefined) {
      playPromise.catch(error => {
        // Autoplay was prevented (expected in many browsers)
        console.log('Autoplay prevented:', error.name);
        this.hasUserPaused = true;
        this.updateState();
      });
    }
  }

  onVideoError(event) {
    const error = this.video?.error;
    if (!error) return;
    
    console.warn('Video error:', {
      code: error.code,
      message: error.message,
      MEDIA_ERR_ABORTED: error.code === 1,
      MEDIA_ERR_NETWORK: error.code === 2,
      MEDIA_ERR_DECODE: error.code === 3,
      MEDIA_ERR_SRC_NOT_SUPPORTED: error.code === 4
    });
    
    // Visual error state
    this.$el.addClass('is-video-error');
    
    // Show fallback image
    this.showFallback();
  }

  onLoadedData() {
    this.$el.removeClass('is-video-loading is-video-error');
    this.$el.addClass('is-video-ready');
  }

  showFallback() {
    // Show poster image or placeholder
    if (this.config._graphic) {
      this.$el.addClass('is-video-fallback');
      this.$('.video__poster').show();
    }
  }
}
```

### Video Element Attributes

```html
<video
  class="video__element"
  playsinline                    <!-- iOS inline play -->
  muted="${isMuted}"             <!-- Required for autoplay in many browsers -->
  loop="${isInfiniteLoop}"       <!-- Native loop (if -1 loops) -->
  preload="metadata"             <!-- Preload strategy -->
  poster="${posterSrc}"          <!-- Fallback image -->
  aria-label="${ariaLabel}"      <!-- Accessibility -->
  aria-hidden="${isDecorative}"> <!-- Hide if decorative -->
  
  <source src="${mp4Src}" type="video/mp4">
  <source src="${webmSrc}" type="video/webm">
  
  <!-- Fallback content -->
  <img src="${posterSrc}" alt="${altText}">
</video>
```

---

## Device-Responsive Assets

### Breakpoint-Based Asset Selection

```javascript
class ResponsiveAssetView extends Backbone.View {
  
  initialize() {
    this.config = this.model.get('_extension');
    this.currentScreenSize = null;
    
    this.listenTo(Adapt, 'device:changed', this.onDeviceChanged);
    this.render(device.screenSize);
  }

  render(screenSize) {
    // Don't re-render if same screen size
    if (this.currentScreenSize === screenSize) return;
    
    this.currentScreenSize = screenSize;
    
    // Get asset for current screen size
    const assetConfig = this.getAssetForScreenSize(screenSize);
    
    if (!assetConfig) {
      console.warn('No asset configured for screen size:', screenSize);
      return;
    }
    
    // Render with appropriate asset
    this.renderAsset(assetConfig);
  }

  getAssetForScreenSize(screenSize) {
    // Adapt device sizes: small, medium, large, xlarge
    const assets = this.config._assets || {};
    
    // Try exact match first
    if (assets[`_${screenSize}`]) {
      return assets[`_${screenSize}`];
    }
    
    // Fallback order
    const fallbackOrder = {
      'small': ['_small', '_medium', '_large', '_xlarge'],
      'medium': ['_medium', '_small', '_large', '_xlarge'],
      'large': ['_large', '_medium', '_xlarge', '_small'],
      'xlarge': ['_xlarge', '_large', '_medium', '_small']
    };
    
    const fallbacks = fallbackOrder[screenSize] || [];
    
    for (const size of fallbacks) {
      if (assets[size]) {
        return assets[size];
      }
    }
    
    return null;
  }

  renderAsset(assetConfig) {
    // Render video/image with config
    const html = `
      <video src="${assetConfig.mp4}" 
             poster="${assetConfig.poster}">
        ${assetConfig.webm ? `<source src="${assetConfig.webm}" type="video/webm">` : ''}
      </video>
    `;
    
    this.$el.html(html);
  }

  onDeviceChanged(screenSize) {
    this.render(screenSize);
  }
}
```

### Configuration Structure

```json
{
  "_extension": {
    "_isEnabled": true,
    "_assets": {
      "_small": {
        "mp4": "course/en/video/mobile.mp4",
        "webm": "course/en/video/mobile.webm",
        "poster": "course/en/images/mobile-poster.jpg"
      },
      "_medium": {
        "mp4": "course/en/video/tablet.mp4",
        "poster": "course/en/images/tablet-poster.jpg"
      },
      "_large": {
        "mp4": "course/en/video/desktop.mp4",
        "webm": "course/en/video/desktop.webm",
        "poster": "course/en/images/desktop-poster.jpg"
      }
    }
  }
}
```

---

## Intersection Observer Pattern

### Viewport Visibility Tracking

```javascript
class IntersectionObserverView extends Backbone.View {
  
  initialize() {
    this.config = this.model.get('_extension');
    this.hasEnteredOnce = false;
    this.setupIntersectionObserver();
  }

  setupIntersectionObserver() {
    // Get threshold from config (0-1, default 0.5)
    const threshold = this.config._onScreenPercentInviewVertical || 0.5;
    
    this.observer = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        const percentInview = entry.intersectionRatio;
        const onscreen = entry.isIntersecting;
        
        this.onScreenChange({
          onscreen,
          percentInview
        });
      });
    }, {
      threshold: [0, 0.25, 0.5, 0.75, 1.0], // Multiple thresholds
      rootMargin: '0px'
    });
    
    this.observer.observe(this.el);
  }

  onScreenChange({ onscreen, percentInview }) {
    const threshold = this.config._onScreenPercentInviewVertical || 0.5;
    const isVisible = onscreen && percentInview >= threshold;
    
    if (isVisible) {
      this.onOnScreen(percentInview);
    } else {
      this.onOffScreen();
    }
  }

  onOnScreen(percentInview) {
    if (!this.hasEnteredOnce) {
      this.hasEnteredOnce = true;
      this.onFirstView();
    }
    
    // Play video, start animation, etc.
    this.$el.addClass('is-onscreen');
    
    if (this.config._playFirstViewOnly && this.hasEnteredOnce) {
      return;
    }
    
    this.play();
  }

  onOffScreen() {
    this.$el.removeClass('is-onscreen');
    
    if (this.config._offScreenPause) {
      this.pause();
    }
    
    if (this.config._offScreenRewind) {
      this.rewind();
    }
  }

  onFirstView() {
    // Track first view for analytics, completion, etc.
    console.log('First view of element');
  }

  remove() {
    // Cleanup observer
    if (this.observer) {
      this.observer.disconnect();
      this.observer = null;
    }
    super.remove();
  }
}
```

### Alternative: Adapt's Built-in InView

```javascript
// Use Adapt's inview utility (if available)
import inview from 'core/js/inview';

class InViewExample extends Backbone.View {
  
  initialize() {
    this.onScreenChange = _.debounce(this.onScreenChange.bind(this), 100);
    this.setupInview();
  }

  setupInview() {
    inview(this.$el, {
      onInview: this.onScreenChange,
      offsetTop: 0,
      offsetBottom: 0
    });
  }

  onScreenChange(event, measurements) {
    const { percentFromTop, percentFromBottom, percentInview, onscreen } = measurements;
    
    // Your logic here
  }
}
```

---

## Error Handling & Fallbacks

### Progressive Enhancement

```javascript
class RobustExtension extends Backbone.View {
  
  initialize() {
    this.errorStates = {
      LOADING: 'loading',
      READY: 'ready',
      ERROR: 'error',
      FALLBACK: 'fallback'
    };
    
    this.currentState = this.errorStates.LOADING;
    this.render();
  }

  render() {
    try {
      this.renderPrimaryFeature();
    } catch (error) {
      console.error('Primary feature failed:', error);
      this.renderFallback();
    }
  }

  renderPrimaryFeature() {
    // Try primary feature (video, animation, etc.)
    this.setState(this.errorStates.LOADING);
    
    // Setup with error handling
    this.setupFeature()
      .then(() => {
        this.setState(this.errorStates.READY);
      })
      .catch((error) => {
        console.error('Feature setup failed:', error);
        this.handleError(error);
      });
  }

  handleError(error) {
    this.setState(this.errorStates.ERROR);
    
    // Determine if we can fallback
    if (this.hasFallback()) {
      this.renderFallback();
    } else {
      this.renderMinimal();
    }
  }

  renderFallback() {
    this.setState(this.errorStates.FALLBACK);
    
    // Show static image, simplified version, etc.
    const fallbackHTML = `
      <div class="extension__fallback">
        <img src="${this.config._graphic.src}" 
             alt="${this.config._graphic.alt}">
      </div>
    `;
    
    this.$el.html(fallbackHTML);
  }

  renderMinimal() {
    // Absolute minimum - just content, no enhancement
    this.$el.addClass('extension--minimal');
  }

  setState(state) {
    // Remove all state classes
    Object.values(this.errorStates).forEach(s => {
      this.$el.removeClass(`is-${s}`);
    });
    
    // Add current state class
    this.$el.addClass(`is-${state}`);
    this.currentState = state;
  }

  hasFallback() {
    return this.config._graphic && this.config._graphic.src;
  }
}
```

### Graceful Degradation CSS

```less
.extension {
  // Loading state
  &.is-loading {
    .extension__content {
      opacity: 0;
    }
    .extension__loader {
      display: block;
    }
  }

  // Ready state
  &.is-ready {
    .extension__content {
      opacity: 1;
      transition: opacity 0.3s;
    }
  }

  // Error state
  &.is-error {
    .extension__primary {
      display: none;
    }
  }

  // Fallback state
  &.is-fallback {
    .extension__primary {
      display: none;
    }
    .extension__fallback {
      display: block;
    }
  }
}
```

---

## Extension-Specific Patterns

### Pattern 1: Decorator Extensions

Add visual enhancements to existing views:

```javascript
// Example: Background video, parallax, animations
class DecoratorExtension extends Backbone.Controller {
  initialize() {
    this.listenTo(Adapt, 'app:dataReady', this.onDataReady);
  }

  onDataReady() {
    this.listenTo(Adapt, {
      'pageView:postRender': this.enhance
    });
  }

  enhance(view) {
    const config = view.model.get('_decorator');
    if (!config?._isEnabled) return;
    
    // Add decoration without disrupting existing view
    const decoration = new DecorationView({ model: view.model });
    view.$el.prepend(decoration.el).addClass('is-decorated');
  }
}
```

### Pattern 2: Behavior Extensions

Add interaction behavior to existing elements:

```javascript
// Example: Drawer navigation, tooltips, hotspots
class BehaviorExtension extends Backbone.Controller {
  initialize() {
    this.listenTo(Adapt, 'app:dataReady', this.onDataReady);
  }

  onDataReady() {
    this.listenTo(Adapt, {
      'articleView:postRender': this.addBehavior
    });
  }

  addBehavior(view) {
    const config = view.model.get('_behavior');
    if (!config?._isEnabled) return;
    
    // Enhance with interactive behavior
    view.$('.js-interactive').each((index, el) => {
      this.setupInteraction($(el), config);
    });
  }

  setupInteraction($el, config) {
    $el.on('click', (e) => {
      // Behavior logic
    });
  }
}
```

### Pattern 3: Data Extensions

Provide data or state across views:

```javascript
// Example: Progress tracking, bookmarking, notes
class DataExtension extends Backbone.Controller {
  initialize() {
    this.data = new Backbone.Model();
    this.listenTo(Adapt, 'app:dataReady', this.onDataReady);
  }

  onDataReady() {
    this.loadData();
    this.setupListeners();
  }

  setupListeners() {
    // Listen to data changes
    this.listenTo(Adapt, 'component:completed', this.onComponentComplete);
  }

  loadData() {
    // Load from localStorage, API, etc.
    const saved = localStorage.getItem('extension-data');
    if (saved) {
      this.data.set(JSON.parse(saved));
    }
  }

  saveData() {
    localStorage.setItem('extension-data', JSON.stringify(this.data.toJSON()));
  }
}
```

---

## Properties Schema for Extensions

### Extension Schema Structure

Extensions apply to multiple content types, so schema is often more complex:

```json
{
  "type": "object",
  "$schema": "http://json-schema.org/draft-04/schema",
  "id": "http://jsonschema.net",
  "properties": {
    "pluginLocations": {
      "type": "object",
      "properties": {
        "config": {
          "type": "object",
          "properties": {
            "_extensionName": {
              "type": "object",
              "legend": "Extension Name",
              "properties": {
                "_isEnabled": {
                  "type": "boolean",
                  "default": false,
                  "title": "Enable Extension",
                  "inputType": "Checkbox"
                }
              }
            }
          }
        },
        "contentobject": {
          "type": "object",
          "properties": {
            "_extensionName": {
              "type": "object",
              "legend": "Extension for Pages",
              "properties": {
                "_isEnabled": {
                  "type": "boolean",
                  "default": false
                }
              }
            }
          }
        },
        "article": {
          "type": "object",
          "properties": {
            "_extensionName": {
              "type": "object",
              "legend": "Extension for Articles"
            }
          }
        },
        "block": {
          "type": "object",
          "properties": {
            "_extensionName": {
              "type": "object",
              "legend": "Extension for Blocks"
            }
          }
        }
      }
    }
  }
}
```

---

## Key Takeaways

### Extensions vs Components

✅ **Extensions** = Enhance existing views  
✅ **Components** = Standalone content  

### Best Practices from adapt-backgroundVideo

1. **React Integration** - Use React for complex UI (Adapt v5.14+)
2. **Device-Responsive Assets** - Different media per breakpoint
3. **Intersection Observer** - Efficient viewport detection
4. **Graceful Degradation** - Always have fallbacks
5. **Video Promises** - Handle play() promise rejection
6. **Reduced Motion** - Respect accessibility preferences
7. **Error States** - Visual feedback for all states
8. **Cleanup** - Remove observers, event listeners
9. **State Management** - Track playback state carefully
10. **Progressive Enhancement** - Work even if features fail

---

**Version History:**
- v1.0.0 (2025-11-08): Initial creation based on adapt-backgroundVideo analysis
